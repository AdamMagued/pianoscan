import { IncomingForm } from 'formidable';
import FormData from 'form-data';
import fs from 'fs';
import fetch from 'node-fetch';

export const config = {
  api: {
    bodyParser: false, // Disallow Next.js from parsing the body, let formidable do it
  },
};

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    // 1. Parse the incoming form data
    const data = await new Promise((resolve, reject) => {
      const form = new IncomingForm();
      form.parse(req, (err, fields, files) => {
        if (err) return reject(err);
        resolve({ fields, files });
      });
    });

    const file = data.files.file?.[0]  data.files.file;
    const engine = data.fields.engine?.[0] 
 'homr';

    if (!file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }

    // 2. Prepare the payload for Python
    const formData = new FormData();
    formData.append('engine', engine);
    formData.append('file', fs.createReadStream(file.filepath), {
      filename: file.originalFilename,
      contentType: file.mimetype,
    });

    console.log([Node Proxy] Forwarding ${file.originalFilename} to Python (Engine: ${engine})...);

    // 3. Send to Ngrok (Your PC)
    // CRITICAL: We must pass the headers generated by formData so the boundary is correct
    const pythonResponse = await fetch('https://nonepisodically-influential-marya.ngrok-free.dev/scan', {
      method: 'POST',
      headers: {
        'X-API-Key': 'GUC_Super_Secret_Key_2026',
        ...formData.getHeaders(), 
      },
      body: formData,
      timeout: engine === 'homr' ? 300000 : 180000, // 5 min timeout for HOMR
    });

    // 4. Handle Response
    if (!pythonResponse.ok) {
      const errorText = await pythonResponse.text();
      console.error([Node Proxy] Python Error (${pythonResponse.status}):, errorText);
      return res.status(pythonResponse.status).json({ 
        error: 'Python Server Error', 
        details: errorText 
      });
    }

    // 5. Success - Stream MIDI back to browser
    const midiBuffer = await pythonResponse.arrayBuffer();
    res.setHeader('Content-Type', 'audio/midi');
    res.send(Buffer.from(midiBuffer));

  } catch (error) {
    console.error('[Node Proxy] Fatal Error:', error);
    return res.status(500).json({ 
      error: 'Proxy Error', 
      details: error.message 
    });
  }
}